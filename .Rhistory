vec <- c(1, 2, 3, 4)
vec
print(vec)
install.packages("ggplot")
install.packages("ggplot2")
library(ggplot2)
library("BSgenome")
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("ropls")
install.packages("devtools")
install_github("LoosC/systemsseRology", ref = "reboot")
library(systemsseRology)
install.packages("devtools")
install_github("LoosC/systemsseRology", ref = "reboot")
devtools::install_github("r-lib/remotes")
devtools::install_github("systemsseRology")
devtools::install_github("LoosC/systemsseRology")-
)
devtools::install_github("LoosC/systemsseRology")
ls
library(systemsseRology)
library(ggplot2)
library(readxl)
data <- data.frame("cov2_data.xls")
data
data <- data.frame("cov2_data.xlsx")
data
data <- as.data.frame("cov2_data.xlsx")
data
data <- read_excel("cov2_data.xlsx")
pwd
pwd
data <- read_excel("cov2_data.xlsx")
knitr::opts_chunk$set(echo = TRUE)
library(systemsseRology)
library(ggplot2)
library(readxl)
data <- read_excel("cov2_data.xlsx")
data
X <- as.matrix(data)
X
data
data[, 5:ncol(data)]
data[, 5:]
nrow(data)
ncol(data)
ncol(data[, 5:ncol(data)])
ncol(data[, 1:ncol(data)])
colnames(data)
data <- read_excel("cov2_data.xlsx")
# convert the measured variables to numeric. There are 5 descriptive variables at the beginning
num_descriptive <- 5
X <- as.matrix(as.data.frame(lapply(data[, (num_descriptive+1):ncol(data)], as.numeric)))
# z-score the data to make features comparable
X <- scale(X, center = TRUE, scale = TRUE)
y <- factor(data$y, levels = unique(data$y))
X
typeof(X)
shape(X)
dim(X)
ncol(data)
colnames(data)
nrow(data)
y <- factor(data$Outcome, levels = unique(data$Outcome))
y
data
tail(Data)
tail(data)
data[rowSums(is.na(data))]
data[rowSums(is.na(data)) == ncol(data),]
data[rowSums(is.na(data)) < ncol(data),]
rowSums(is.na(data))
length(rowSums(is.na(data)))
rowSums(data)
rowSums(X)
colSums(X)
nrows(X)
nrows(data)
nrow(X)
rowSums(is.na(data))
ncol(data)
data <- read_excel("cov2_data.xlsx")
# remove rows and columns that have only NaNs by keeping only
data <- data[rowSums(is.na(data)) < ncol(data),]
data <- data[colSums(is.na(data)) < nrow(data),]
data
colSums(is.na(data))
nrow(data)
data <- read_excel("cov2_data.xlsx")
# remove rows and columns that have only NaNs by keeping only
data <- data[rowSums(is.na(data)) < ncol(data), ]
data <- data[, colSums(is.na(data)) < nrow(data)]
# convert the measured variables to numeric. There are 5 descriptive variables at the beginning
num_descriptive <- 5
X <- as.matrix(as.data.frame(lapply(data[, (num_descriptive+1):ncol(data)], as.numeric)))
# z-score the data to make features comparable
X <- scale(X, center = TRUE, scale = TRUE)
y <- factor(data$Outcome, levels = unique(data$Outcome))
data
dim(data)
tail(data)
colnames(data)
y
X
colnames(data)
length(X)
X
length(y)
dim(data)
knitr::opts_chunk$set(echo = TRUE)
library(systemsseRology)
library(ggplot2)
library(readxl)
data <- read_excel("cov2_data.xlsx")
# remove rows and columns that have only NaNs by keeping only
data <- data[rowSums(is.na(data)) < ncol(data), ]
data <- data[, colSums(is.na(data)) < nrow(data)]
# convert the measured variables to numeric. There are 5 descriptive variables at the beginning
num_descriptive <- 5
# extract numerical values and put into matrix
X <- as.matrix(as.data.frame(lapply(data[, (num_descriptive+1):ncol(data)], as.numeric)))
# z-score the data to make features comparable
X <- scale(X, center = TRUE, scale = TRUE)
y <- factor(data$Outcome, levels = unique(data$Outcome))
df_features <- data.frame(name = colnames(X))
df_features
dim(X)
colnames(df_features)
gsub("_.*", "", df_features$name)
ls
pwd
read.delim("GSE157220_CPM_data.txt", sep="\t")
read.delim("Desktop/git/biophys206_finalProject/GSE157220_CPM_data.txt", sep="\t")
a <- c(3, 0, TRUE)
b <- c(4, 0, FALSE)
(a | b)
upper.tri(a)
a[upper.tri(a)]
a[upper.tri(b)]
cbind(a, b)
cbind(a, b)[upper.tri(cbind(a, b))]
as.POSIXct("Sep-28-2019 07:54:31 AM UTC")
as.POSIXct("Sep-28-2019 07:54:31 AM UTC", format="%b-%d-%Y")
as.POSIXct("Sep-28-2019 07:54:31 AM", format="%b-%d-%Y")
fotma(as.POSIXct("Sep-28-2019 07:54:31 AM", format="%b-%d-%Y"))
x <- as.Date("2018-10-01")
month(x)
as.month(x)
months(x)
attr(x)
x <- c(12L)
x <- c(12L, 4L, 10L, 8L, 15L, 14L, 19L, 18L, 23L, 59L)
median(x)
typeof(median(x))
library("swirl")
install.packages("swirl")
library("swirl")
swirl()
plot(child ~ parent, galton)
swirl()
## Load deSolve so we can use the ode() command
library(deSolve)
## Set your time steps, initial values, parameters
times <- seq(0, 100, by = 1)
yinit <- c(no_headache = 0.5, headache = 0.5)
## Differential equations of headaches (or non-infectious diseases)
## Last modified: Jan 24 2018
## Load deSolve so we can use the ode() command
library(deSolve)
## Set your time steps, initial values, parameters
times <- seq(0, 100, by = 1)
yinit <- c(no_headache = 0.5, headache = 0.5)
parameters <- c(incidence = 0.01, recovery = 1/2)
## Create an ODE model -- the solver needs your model written as a function
## that takes in a vector of times, initial values, and parameters
## (in that order) and returns a list with derivatives of your compartments
## relative to time.
headache_model <- function(times, yinit, parameters) {
with(as.list(c(yinit, parameters)), {
## Define your no headache compartment
dno_headache <- recovery*headache - incidence*no_headache
## Define your headache compartment
dheadache <- incidence*no_headache - recovery*headache
## Save your compartments into a new variable, as a list
comparts <- list(c(dno_headache, dheadache))
## Don't forget you need to return your compartments
return(comparts)
})
}
## Run your model
result <- as.data.frame(ode(y = yinit, times = times,
func = headache_model, parms = parameters))
# prevalence at equilibrium
tail(result$headache,1)
# prevalence odds
tail(result$headache,1)/(1+tail(result$headache,1))
# incidence * duration (1/recovery rate)
parameters[1]*(1/parameters[2])
## Plot it
matplot(x = result[, "time"],
y = result[, c("no_headache", "headache")],
type = "l")
## Try help(matplot) to find an option that will truncate the x-axis for you
## to help visualize these data better.
# EPI501 Week 2 exercise
# SIR practical from Debarre and Bonhoeffer ("SIR models of epidemics")
## Load deSolve so we can use the ode() command
library(deSolve)
## Set your time steps, initial values, and parameters based on information provided in the question:
# Hint: make sure all your parameters are coded using the same time units (e.g. weeks vs. days).
# Also make sure that your time steps are in the same time units as your parameters.
dt <- seq(0,365,1)
inits <- c(S=999999, I=1, R=0)
parms <- c(b=0.75, k=12/7, r=1/7)
## Create an ODE model -- the solver needs your model written as a function
## that takes in a vector of times, initial values, and parameters
## (in that order) and returns a list with derivatives of your compartments
## relative to time.
# This is our function for a simple SIR model without births and deaths named "SIR":
# For subsequent questions, create new functions using this one as a starting point.
# You'll have to change the equations / compartments and update "der," which groups the output (lines 31-35).
SIR <- function(t, x, parms){ # do not change the order of these inputs
# t is the vector of time-steps;
# x is the current state of the model;
# parms is the vector of parameters
with(as.list(c(parms,x)),{ # "with" allows us to refer to parms and x by shorthand
dS <- - (b*k*S*I)/(S+I+R)
dI <- + (b*k*S*I)/(S+I+R) - r*I
dR <- r*I
der <- c(dS, dI,dR)
list(der) # the output must be returned as a list
}) # end of 'with'
} # end of function definition
## Run your model
simulation <- as.data.frame(lsoda(y = inits, times = dt, func = SIR, parms = parms))
## Check first few rows of the simulation results
head(simulation, 10)
## Check final values
tail(simulation, 10)
## Plot results
matplot(simulation[,1],simulation[,2:4],type="l", lty = 1, xlab = "Time", main = "Measles w/ 1/7 r", ylab = "Individuals")
legend(x = "right", legend = c('S', 'I', 'R'), col = 1:3, lty = 1)
# You can run ?matplot and ?legend to see more plotting options
## For questions 5-6, check the prevalence at equilibrium
tail(simulation,1)$I/sum(inits)
install.packages("taxonomizr")
library(taxonomizr)
getNamesAndNodes()
getAccession2taxid()
getAccession2taxid()
prepareDatabase('accessionTaxa.sql')
library(dplyr)
library(ggtree)
library(treeio)
library(magrittr)
library(ggplot2)
setwd("Desktop/git/niv_evo")
metadata <- read.csv("metadata_all.csv")
metadata[metadata == "nan"] <- "unknown"
metadata$Clade %<>% factor
# whitmer_isolates_tree <- function(tree_file, metadata) {
#
#   tree <- read.tree(tree_file)
#   fName <- strsplit(basename(tree_file), split="\\.")[[1]][1]
#
#   p = ggtree(tree) %<+% metadata +
#     geom_tippoint() +
#     geom_nodelab(size=4, hjust = 1.5, vjust = -0.5) +
#     geom_tiplab(aes(color = Clade), size=5, show.legend=TRUE) +
#     scale_colour_manual(na.translate = F,
#                         name="Clade",
#                         values=c("blue","red")
#     ) +
#     guides(color = guide_legend(override.aes = list(label = "\u25CF", size = 6))) +
#     theme(legend.title = element_text(size=20),
#           legend.text = element_text(size=17),
#           legend.position = c(0.1, 0.9)) +
#     geom_treescale(x=0, y=21, fontsize=5, linesize=1, offset=-0.8)
#
#   ggsave(paste(dirname(tree_file), "/", fName, ".png", sep=""), width = 55, height = 30, units = "cm", limitsize = FALSE)
#
# }
#
# whitmer_isolates_tree("trees/P_whitmer_BGD_FT.nwk", metadata)
# whitmer_isolates_tree("trees/G_whitmer_BGD_FT.nwk", metadata)
create_tree <- function(tree_file) {
tree <- read.tree(tree_file)
p = ggtree(tree, branch.length="none") %<+% metadata +
geom_tippoint(aes(shape=Host), size=3) +
geom_nodelab(size=4, hjust = 1.7, vjust = -0.5) +
geom_tiplab(aes(color=Country), size=5, show.legend=TRUE) +
scale_colour_manual(na.translate = F,
name="Country",
values=c("royalblue","darkorange", "darkgreen", "purple", "black")
) +
scale_shape_manual(na.translate = F,
values = c(16, 17, 8)) +
guides(color = guide_legend(override.aes = list(label = "\u25CF", size = 4))) +
guides(shape = guide_legend(override.aes = list(label = "\u25CF", size = 3))) +
theme(legend.title = element_text(size=20),
legend.text = element_text(size=15),
legend.position = c(0.05, 0.85))
png_file = paste(tools::file_path_sans_ext(tree_file), ".png", sep="")
ggsave(png_file, width = 60, height = 30, units = "cm", limitsize = FALSE)
}
create_tree("trees/P_no_stop_codons_FT.nwk")
create_tree("trees/G_no_stop_codons_ML.nwk")
create_tree("trees/P_no_stop_codons_ML.nwk")
create_tree("trees/P_no_stop_codons_ML.nwk")
create_tree("trees/P_no_stop_codons_ML.nwk")
create_tree("trees/G_no_stop_codons_ML.nwk")
create_tree("trees/P_no_stop_codons_FT.nwk")
create_tree("trees/G_no_stop_codons_FT.nwk")
create_tree("trees/G_no_stop_codons_ML.nwk")
create_tree("trees/G_no_stop_codons_ML.nwk")
create_tree("trees/P_no_stop_codons_ML.nwk")
